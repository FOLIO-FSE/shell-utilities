filelist=("$@")
infile="${filelist[0]}"
if [[ -z ${infile} ]];then echo "You must supply a file name or expression (wildcards OK). Usage: filefix [filename]";fi

if [[ -z $1 ]];then
	echo "This tool converts csv data to tsv, performs basic cleaning, and does field frequency counts "
	echo "It detects date formats and converts MM-DD-YYYY and DD-MM-YYYY dates to YYYY-MM-DD. "
	echo 
	echo "Usage: filefix [filename]"
	echo "You will be prompted for optional functionality"
	echo
	exit
else
	infile=${1}
fi

function fix_file() {
infile=${1}

echo
echo "################ Processing ${infile} #####################"
echo
echo "Detecting and removing trailing carriage returns"
echo

head -50 ${infile} |grep -o "\b[0-9][2-3]-[0-9][0-9]-[12][09][0-9][0-9]\b" > /dev/null &&  dateformat="us"
head -50 ${infile} |grep -o "\b[2-3][0-9]-[0-9][0-9]-[12][09][0-9][0-9]\b" > /dev/null && dateformat="uk"

if [[ ${dateformat} == "uk" ]];then echo "UK dates detected. DD-MM-YYYY dates will be converted to YYYY-MM-DD";fi
if [[ ${dateformat} == "us" ]];then echo "US dates detected. MM-DD-YYYY dates will be converted to YYYY-MM-DD";fi

if [[ ! -f ${infile} ]];then echo "The input file ${infile} could not be found";exit;fi

sed -i 's/\r$//' ${infile}
iconv -f utf-8 -t utf-8 -c ${infile} -o tmp_infile
mv tmp_infile ${infile}

# detect file characteristics. First line is assumed to contain either tabs or commas

if awk '{exit !/\t/}' ${infile}; then 
	filetype="tab"
elif awk '{exit !/\|/}' ${infile}; then filetype="pipe"
		echo "Pipe delimited file detected. Converting ${infile} to tab delimited."
		echo "Please be patient."
		outfile=$(sed 's/\.....\?$//' <<< ${infile})
		cat ${infile} |sed 's/|/\t/g' > "${outfile}.tsv"
		infile="${outfile}.tsv"
		echo "Conversion to tab delimited complete"
		echo

elif awk '{exit !/,/}' ${infile}; then filetype="comma"
		echo "Comma delimited file detected. Converting ${infile} to tab delimited."
		echo "Please be patient."
		outfile=$(sed 's/\.....\?$//' <<< ${infile})
		#csvtool -t COMMA -u TAB cat ${infile} > "${outfile}.tsv"
		csvformat -T "${infile}" > "${outfile}"
		infile="${outfile}.tsv"
		echo "Conversion to tab delimited complete"
		echo
fi

if [[ ! $filetype ]];then
	echo "${infile} doesn't appear to be comma or tab delimited."
	echo "Please supply a different file or correct the first line."
	echo
	exit
fi

read -r fieldnames < ${infile}

numrecs=$(wc -l ${infile} |cut -d " " -f1)
numfields=$(awk 'BEGIN{FS="\t"}{print NF;exit}' ${infile})

echo
echo "$numfields fields $numrecs lines were detected."
echo "Problematic characters will be removed from fieldnames"
echo


fieldnames=$(tr -dc "[[A-Za-z0-9]]_	\-#." <<< "${fieldnames}")
echo "The following fields were detected in ${infile}"
echo
echo "${fieldnames}" |tr "\t" "\n" |grep -n .
echo

# normalize fieldnames in file
sed -i '1 s/[^0-9A-Za-z_\-#)(\.\t]//g' ${infile}

echo
echo "Stripping double quotes from the edges of fields, converting smartquotes, and removing trailing spaces from fields"
echo

SINGLE=$(echo -ne '\u00B4\u2018\u2019')
DOUBLE=$(echo -ne '\u201C\u201D')
NBSP=$(echo -ne '\uc2a0\u00a0\ufeff')
CONTROL=$(echo -ne '\u001b\u0007\u0001')
sed -i "s/['\"]*\t['\"]*/\t/g; s/^['\"]//; s/['\"];/;/g; s/;['\"]/;/g; s/['\"]$//;s/[$SINGLE]/'/g; s/[$DOUBLE]/\"/g; s/[$NBSP]/ /g; s/[$CONTROL]/ /g; s/\([^\t]\) *\t/\1\t/g" "${infile}"

echo

if [[ ${dateformat} == "us" ]]; then
	echo "No UK formatted dates detected in first 50 lines"
	echo "Converting MM-DD-YYYY dates to YYYY-MM-DD and stripping blank dates"
	sed -i 's/\b\([0-9][0-9]\)-\([0-9][0-9]\)-\([0-9][0-9][0-9][0-9]\)\b/\3-\1-\2/g;s/ \+-  -\( \+\)\?//g' "${infile}"
else 
	echo "Converting DD-MM-YYYY dates to YYYY-MM-DD and stripping blank dates"
	sed -i 's/\b\([0-9][0-9]\)-\([0-9][0-9]\)-\([0-9][0-9][0-9][0-9]\)\b/\3-\2-\1/g;s/ \+-  -\( \+\)\?//g;' "${infile}"
fi

fieldcounters="${fieldcounters// /}"

read -r -d '' awkscript << "ENDOFAWK"
#!/usr/bin/awk -f

BEGIN {
	FS=OFS="\t"
	goodrecs=badrecs=0
}

{
	if (NR == 1) {
		print header > outfile
	} else {
		if (NF == numfields) {
			goodrecs++
			for(i=1;i<=NF;i++) {
				printf("%s%s",$i,i==NF?RS:OFS) > outfile
			}
	
		} else {
			badrecs++
			print $0 > badfile
		}
	
		if(NR % 10000 == 0 ) {printf ("Processed %d items\r", NR)}
	}
}
END {
	print "Processed " NR - 1 " items."
	print goodrecs " good records were output to " outfile " and" 
	print badrecs " records with the wrong number of fields were output to " badfile
	print ""

}
ENDOFAWK

echo -e "${awkscript}" > tmp_awk
chmod 700 tmp_awk

if [[ "${infile}" =~ \....$ ]];then
	outfile=$(echo "${infile}" |sed 's/\(.*\)\(\....$\)/\1_fixed\2/')
else
	outfile="${infile}_fixed"
fi
badfile="${infile}_error"

awk -v numrecs=$numrecs -v numfields=$numfields -v header="${fieldnames}" -v outfile=$outfile -v badfile=$badfile -v fieldcounters=$fieldcounters -f tmp_awk ${infile}
rm tmp_awk
}

for file in "${filelist[@]}";do
	fix_file "${file}"
done

#!/usr/bin/bash

if [[ -z ${3} ]];then
	echo "Extracts the id field from a JSON file using a matching file with values for a specified key"
	echo
	echo "JSON key must be specified in jq syntax minus leading dot in first element"
	echo
	echo "Usage: jqfindmatches [jsonfile] [valuefile] [jsonkey]"
	echo
	echo "Example: jqfindmatches myfile.json ids id"
	exit
else
	jsonfile="${1}"
	valuefile="${2}"
	jsonkey="${3}"
fi

cat "${valuefile}" |jq -R . > "tmp_vals"


if [[ "${jsonkey}" =~ ^([^[]+)\[([^]]+)\]$ ]]; then
	key="${BASH_REMATCH[1]}"
	val="${BASH_REMATCH[2]}"
	jsonkey="$(printf '["%s", %s]\n' "$key" "$val")"

	echo "Finding matching records. Please wait"
	jq -rc --slurpfile all_values tmp_vals --argjson PATH "${jsonkey}" 'select(getpath($PATH) | IN($all_values[]))|.id' "${jsonfile}" |pv > matched_ids.txt

	echo "Finding nonmatching records. Please wait"
	jq -rc --slurpfile all_values tmp_vals --argjson PATH "${jsonkey}" 'select(getpath($PATH) | IN($all_values[])|not)|.id' "${jsonfile}" |pv > not_matched_ids.txt
else
	echo "Finding matching records. Please wait"
	jq -rc --slurpfile all_values tmp_vals --argjson KEY "${jsonkey}" 'select(.$[KEY] | IN($all_values[]))|.id ' "${jsonfile}" |pv > matched_ids.txt

	echo "Finding nonmatching records. Please wait"
	jq -rc --slurpfile all_values tmp_vals --argjson KEY "${jsonkey}" 'select(.[$KEY] | IN($all_values[]) |not)|.id ' "${jsonfile}" |pv > not_matched_ids.txt
fi

echo "Ids of matching records have been output to matched_ids.txt. Ids of nonmatching records have been output to not_matched_ids.txt"

rm tmp_vals
